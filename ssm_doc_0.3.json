Yes — what you’re showing is NRQL against ServerlessSample, and that’s totally valid. In New Relic there are usually two “worlds” for Lambda data:

ServerlessSample = New Relic’s serverless event dataset (good for per-function charts like invocations/duration/errors; often tied to entityGuid)

Metric (e.g., aws.lambda.*) = CloudWatch-metric-style time series (good for cross-account/standardized AWS metrics, depends on AWS integration)


If your org’s existing queries are built on ServerlessSample, then you should keep your dashboard consistent and use that dataset.

Below is a copy/paste dashboard kit built on ServerlessSample, designed specifically for your daily Step Functions → 7 Lambdas workflow.


---

1) The most important panels (Daily Job Health)

Panel A — “Did it run in the last 26 hours?”

Pick ONE “anchor” Lambda:

best is the last step (AuditBackup-PersistToRds)

or the first step (AuditBackup-GatherAccounts)


If you’re using entityGuid like your screenshot:

SELECT sum(provider.invocations.Sum)
FROM ServerlessSample
WHERE entityGuid = '<GUID_OF_PersistToRds>'
SINCE 26 hours ago

Interpretation:

> 0 = ran

= 0 = did not run → treat as incident


> If you don’t want to hardcode GUID, use function name attributes (if present in your account): see Section 3.




---

Panel B — “Any errors in the last 26 hours?”

SELECT sum(provider.errors.Sum)
FROM ServerlessSample
WHERE entityGuid IN (
  '<GUID1>','<GUID2>','<GUID3>','<GUID4>','<GUID5>','<GUID6>','<GUID7>'
)
SINCE 26 hours ago

If your account doesn’t have provider.errors.Sum, sometimes it’s provider.errorCount.Sum or similar. Quick check:

SELECT keyset()
FROM ServerlessSample
WHERE entityGuid = '<ONE_GUID>'
SINCE 7 days ago
LIMIT 1


---

Panel C — “Did the whole workflow complete?”

This is the “coverage” check: all 7 functions invoked at least once.

Option 1 (simple, manual): show invocations per function as bars; you visually see if any is zero.

SELECT sum(provider.invocations.Sum)
FROM ServerlessSample
WHERE entityGuid IN ('<GUID1>','<GUID2>','<GUID3>','<GUID4>','<GUID5>','<GUID6>','<GUID7>')
FACET entityName
SINCE 26 hours ago

If any bar is missing/0, the workflow likely broke mid-way.


Option 2 (more “binary”): count how many functions had invocations > 0 (harder to do perfectly in NRQL). So I recommend Option 1 for dashboard + an alert on the last-step function.


---

2) Performance panels (daily batch-friendly)

Panel D — “Duration trend (max) per function — last 7 days”

Daily jobs produce sparse data; max is usually more meaningful than percentiles.

SELECT max(provider.duration.Maximum)
FROM ServerlessSample
WHERE entityGuid IN ('<GUID1>','<GUID2>','<GUID3>','<GUID4>','<GUID5>','<GUID6>','<GUID7>')
FACET entityName
SINCE 7 days ago
TIMESERIES 1 day

If your duration field is different, use keyset() as above to confirm. Sometimes it’s:

provider.duration.Average

provider.duration.Sum

duration (already in ms)

aws.lambda.duration (less likely in ServerlessSample)


Panel E — “Invocations timeseries — last 7 days (expect 1 spike/day)”

SELECT sum(provider.invocations.Sum)
FROM ServerlessSample
WHERE entityGuid = '<GUID_OF_anchor_lambda>'
SINCE 7 days ago
TIMESERIES 1 hour

This produces the “one spike per day” shape you showed.


---

3) Avoid hardcoding GUIDs (if your attributes allow it)

Many accounts have fields like functionName, aws.lambda.functionName, entityName, or tags.

Run this once on one function:

SELECT keyset()
FROM ServerlessSample
WHERE entityGuid = '<ONE_GUID>'
SINCE 7 days ago
LIMIT 1

Look for anything like:

entityName (almost always there)

aws.region, aws.accountId

functionName / aws.lambda.functionName

tags like environment, service, team


If you find a usable name field, you can do:

SELECT sum(provider.invocations.Sum)
FROM ServerlessSample
WHERE entityName LIKE 'AuditBackup-%'
SINCE 26 hours ago
FACET entityName

That’s much easier to maintain than copying GUIDs.


---

4) The two alerts you actually need (for daily jobs)

Alert 1 — “No run in 26h” (anchor lambda)

Condition: invocations == 0 over 26 hours.

NRQL condition query:

SELECT sum(provider.invocations.Sum)
FROM ServerlessSample
WHERE entityGuid = '<GUID_OF_PersistToRds>'
SINCE 26 hours ago

Alert 2 — “Errors happened in last run window”

SELECT sum(provider.errors.Sum)
FROM ServerlessSample
WHERE entityGuid IN ('<GUID1>','<GUID2>','<GUID3>','<GUID4>','<GUID5>','<GUID6>','<GUID7>')
SINCE 26 hours ago

This avoids the classic mistake: using 5-minute windows on something that runs once a day.


---

5) What I would build for your Backup Audit dashboard (minimal + clear)

Top row (big numbers / billboard):

1. Ran in last 26h? (anchor invocations)


2. Any errors in last 26h? (sum errors)


3. Workflow completeness (invocations FACET entityName; quick scan)



Second row: 4) Duration max per function (7d) (timeseries 1 day) 5) Invocations trend (7d) (anchor timeseries)

Third row (drill-down): 6) Errors per function (7d) (FACET entityName) 7) Link-out to the Step Function / CloudWatch logs / NR Logs (optional)


---

One thing you should do next (fast, and it will remove 80% friction)

Run keyset() on one of those Lambdas and paste the result (or a screenshot).
Then I can rewrite the queries to use stable fields (like entityName LIKE 'AuditBackup-%', plus account/region filters) so you don’t have to maintain GUID lists.

If you want, tell me which lambda you want as the “anchor” (I’d pick PersistToRds) and I’ll give you the exact final panel list + exact queries in the order you should add them.
